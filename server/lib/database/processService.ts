/**
 * Process Service - Handl      const { data: process,      const { data: processes, error } = await supabase
        .from('processes')
        .select(`
          *,
          timeline_events (*)
        `)
        .eq('customer_id', customerId)
        .order('created_at', { ascending: false }); = await supabase
        .from('processes  async createProcessTimelineEvent(event: { processId: string; stage: string; description: string; date: string }): Promise<ProcessTimelineEvent> {
    try {
      console.log('ProcessService.createProcessTimelineEvent called with:', event);
      
      const { data: createdEvent, error } = await supabase
        .from('process_timeline_events')
        .insert({
          process_id: event.processId,
          stage: event.stage,
          description: event.description || '',
          date: event.date
          // created_at will be automatically set by the database DEFAULT NOW()
          // id will be automatically generated by uuid_generate_v4()
        })
        .select()
        .single();ect(`
          *,
          timeline_events (*)
        `)
        .eq('id', id)
        .single();rocess-related database operations
 */

import { supabase } from '../supabase.js';
import type { Process, ProcessTimelineEvent } from '../../../shared/types/index.js';

export class ProcessService {
  
  async getAllProcesses(): Promise<Process[]> {
    try {
      const { data: processes, error } = await supabase
        .from('processes')
        .select(`
          *,
          process_timeline_events (*)
        `)
        .order('created_at', { ascending: false });

      if (error) throw error;

      return processes.map(this.transformProcessRow);
    } catch (error) {
      console.error('Error fetching processes:', error);
      throw error;
    }
  }

  async getProcessById(id: string): Promise<Process | null> {
    try {
      const { data: process, error } = await supabase
        .from('processes')
        .select(`
          *,
          process_timeline_events (*)
        `)
        .eq('id', id)
        .single();

      if (error) throw error;
      if (!process) return null;

      return this.transformProcessRow(process);
    } catch (error) {
      console.error('Error fetching process:', error);
      throw error;
    }
  }

  async getProcessesByCustomerId(customerId: string): Promise<Process[]> {
    try {
      const { data: processes, error } = await supabase
        .from('processes')
        .select(`
          *,
          process_timeline_events (*)
        `)
        .eq('customer_id', customerId)
        .order('created_at', { ascending: false });

      if (error) throw error;

      return processes.map(this.transformProcessRow);
    } catch (error) {
      console.error('Error fetching processes by customer:', error);
      throw error;
    }
  }

  async createProcess(processData: Omit<Process, 'id' | 'timeline'>): Promise<Process> {
    try {
      // Generate a unique ID for the process
      const processId = `process-${Date.now()}`;
      console.log(`Generated process ID: ${processId}`);
      
      // Use customer ID as is - it's already in the correct string format with "c-" prefix
      const customerId = processData.customerId;
      console.log(`Using customer ID: ${customerId}`);

      const { data: process, error } = await supabase
        .from('processes')
        .insert({
          id: processId,
          name: processData.name,
          description: processData.description || null,
          jira_ticket: processData.jiraTicket,
          status: processData.status,
          start_date: processData.startDate,
          due_date: processData.dueDate,
          end_date: processData.endDate,
          sdlc_stage: processData.sdlcStage,
          estimate: processData.estimate,
          dev_sprint: processData.devSprint,
          approval_status: processData.approvalStatus,
          approved_date: processData.approvedDate,
          deployed_date: processData.deployedDate,
          functional_area: processData.functionalArea,
          contact_id: processData.responsibleContactId || null,
          output_delivery_method: processData.outputDeliveryMethod || null,
          output_delivery_details: processData.outputDeliveryDetails,
          customer_id: customerId,  // Use the customer ID string directly
          // TPA fields
          is_tpa_required: processData.isTpaRequired || false,
          tpa_responsible_contact_id: processData.tpaResponsibleContactId || null,
          tpa_data_source: processData.tpaDataSource || null,
          tpa_start_date: processData.tpaStartDate || null,
          tpa_end_date: processData.tpaEndDate || null
        })
        .select()
        .single();

      if (error) throw error;

      // Try to create initial timeline event, but don't fail if it doesn't work
      try {
        const initialEvent = await this.addTimelineEvent(process.id, {
          title: `Process Created`,
          description: `Process created in ${processData.sdlcStage} stage`,
          eventType: processData.sdlcStage || 'Requirements', // Use a valid SDLC stage
          date: new Date().toISOString()
        });
        console.log('Initial timeline event created:', initialEvent);
      } catch (timelineError) {
        console.warn('Failed to create initial timeline event, but process was created successfully:', timelineError);
      }

      return this.getProcessById(process.id) as Promise<Process>;
    } catch (error) {
      console.error('Error creating process:', error);
      throw error;
    }
  }

  async updateProcess(id: string, updates: Partial<Process>): Promise<Process> {
    try {
      console.log('Starting process update for id:', id, 'with updates:', updates);
      
      const currentProcess = await this.getProcessById(id);
      if (!currentProcess) {
        console.error('Process not found with id:', id);
        throw new Error('Process not found');
      }
      
      console.log('Found current process:', currentProcess);

      // Temporarily filter out missing columns
      const filteredUpdates: any = {};
      if (updates.name !== undefined) filteredUpdates.name = updates.name;
      if (updates.description !== undefined) filteredUpdates.description = updates.description || null;
      if (updates.jiraTicket !== undefined) filteredUpdates.jira_ticket = updates.jiraTicket;
      if (updates.status !== undefined) filteredUpdates.status = updates.status;
      if (updates.startDate !== undefined) filteredUpdates.start_date = updates.startDate;
      if (updates.dueDate !== undefined) filteredUpdates.due_date = updates.dueDate;
      if (updates.endDate !== undefined) filteredUpdates.end_date = updates.endDate;
      if (updates.sdlcStage !== undefined) filteredUpdates.sdlc_stage = updates.sdlcStage;
      if (updates.estimate !== undefined) filteredUpdates.estimate = updates.estimate;
      if (updates.devSprint !== undefined) filteredUpdates.dev_sprint = updates.devSprint;
      if (updates.approvalStatus !== undefined) filteredUpdates.approval_status = updates.approvalStatus;
      if (updates.approvedDate !== undefined) filteredUpdates.approved_date = updates.approvedDate;
      if (updates.deployedDate !== undefined) filteredUpdates.deployed_date = updates.deployedDate;
      if (updates.functionalArea !== undefined) filteredUpdates.functional_area = updates.functionalArea;
      if (updates.outputDeliveryMethod !== undefined) filteredUpdates.output_delivery_method = updates.outputDeliveryMethod;
      if (updates.outputDeliveryDetails !== undefined) filteredUpdates.output_delivery_details = updates.outputDeliveryDetails;
      
      // Map responsibleContactId to the correct database column
      if (updates.responsibleContactId !== undefined) filteredUpdates.contact_id = updates.responsibleContactId || null;
      
      // TPA fields
      if (updates.isTpaRequired !== undefined) filteredUpdates.is_tpa_required = updates.isTpaRequired;
      if (updates.tpaResponsibleContactId !== undefined) filteredUpdates.tpa_responsible_contact_id = updates.tpaResponsibleContactId || null;
      if (updates.tpaDataSource !== undefined) filteredUpdates.tpa_data_source = updates.tpaDataSource || null;
      if (updates.tpaStartDate !== undefined) filteredUpdates.tpa_start_date = updates.tpaStartDate || null;
      if (updates.tpaEndDate !== undefined) filteredUpdates.tpa_end_date = updates.tpaEndDate || null;
      
      // Skip progress field as it doesn't exist in the database
      // if (updates.progress !== undefined) filteredUpdates.progress = updates.progress;
      
      // Always update the updated_at timestamp
      filteredUpdates.updated_at = new Date().toISOString();
      
      console.log('Updating process with filtered data:', filteredUpdates);

      const { data: process, error } = await supabase
        .from('processes')
        .update(filteredUpdates)
        .eq('id', id)
        .select()
        .single();

      if (error) {
        console.error('Supabase error updating process:', {
          message: error.message,
          details: error.details,
          hint: error.hint,
          code: error.code,
          filteredUpdates
        });
        throw new Error(`Failed to update process: ${error.message}`);
      }

      // Create timeline events for changes after the database update succeeds
      const timelinePromises = [];
      
      // Add timeline event if SDLC stage changed
      if (updates.sdlcStage && updates.sdlcStage !== currentProcess.sdlcStage) {
        timelinePromises.push(
          this.addTimelineEvent(id, {
            title: `Moved to ${updates.sdlcStage}`,
            description: `Process moved from ${currentProcess.sdlcStage} to ${updates.sdlcStage} stage`,
            eventType: updates.sdlcStage, // Use the new stage value as the event type
            date: new Date().toISOString()
          }).catch(error => {
            console.error('Error creating SDLC stage change timeline event:', error);
            return null; // Return null instead of rejecting the promise
          })
        );
      }

      // Add timeline event if status changed
      if (updates.status && updates.status !== currentProcess.status) {
        timelinePromises.push(
          this.addTimelineEvent(id, {
            title: `Status Changed`,
            description: `Process status changed from ${currentProcess.status} to ${updates.status}`,
            eventType: currentProcess.sdlcStage || 'Requirements', // Use current stage as event type
            date: new Date().toISOString()
          }).catch(error => {
            console.error('Error creating status change timeline event:', error);
            return null; // Return null instead of rejecting the promise
          })
        );
      }
      
      // Wait for all timeline events to be created (or fail gracefully)
      if (timelinePromises.length > 0) {
        try {
          await Promise.allSettled(timelinePromises);
        } catch (timelineError) {
          console.error('Error creating timeline events, but process was updated:', timelineError);
          // Continue without failing the whole update
        }
      }

      // Ensure we get the full process with updated timeline events
      const updatedProcess = await this.getProcessById(id);
      console.log('Updated process with timeline:', updatedProcess);
      return updatedProcess as Process;
    } catch (error) {
      console.error('Error updating process:', error);
      throw error;
    }
  }

  async deleteProcess(id: string): Promise<void> {
    try {
      const { error } = await supabase
        .from('processes')
        .delete()
        .eq('id', id);

      if (error) throw error;
    } catch (error) {
      console.error('Error deleting process:', error);
      throw error;
    }
  }

  async addTimelineEvent(processId: string, event: { title: string; description: string; eventType: string; date: string }): Promise<any> {
    try {
      console.log('Adding timeline event:', {
        processId,
        event,
        tableName: 'process_timeline_events',
        mappedEvent: {
          process_id: processId,
          stage: event.eventType,
          description: event.description,
          date: event.date,
          id: `event-${Date.now()}`
        }
      });

      // First verify if the process exists
      const { data: processExists, error: processError } = await supabase
        .from('processes')
        .select('id')
        .eq('id', processId)
        .single();
      
      if (processError) {
        console.error(`Process ID ${processId} not found:`, processError);
        // Don't throw here, just log and continue with a placeholder
        return {
          id: 'error-' + Date.now(),
          date: event.date,
          stage: event.eventType,
          description: `Error: ${processError.message}`
        };
      }

      // Safeguard to ensure all required fields are present
      const insertData = {
        process_id: processId,
        stage: event.eventType || 'general',  // Changed from event_type to stage
        description: event.description || '',
        date: event.date || new Date().toISOString(),
        // Using timestamp for ID to ensure uniqueness
        id: `event-${Date.now()}`
      };

      const { data: timelineEvent, error } = await supabase
        .from('process_timeline_events')
        .insert(insertData)
        .select()
        .single();

      if (error) {
        console.error('Supabase error creating timeline event:', {
          message: error.message,
          details: error.details,
          hint: error.hint,
          code: error.code,
          event: insertData
        });
        
        // Return a placeholder instead of throwing
        return {
          id: 'error-' + Date.now(),
          date: event.date,
          stage: event.eventType,
          description: `Database Error: ${error.message}`
        };
      }

      return {
        id: timelineEvent.id,
        date: timelineEvent.date,
        stage: timelineEvent.stage,
        description: timelineEvent.description
      };
    } catch (error) {
      console.error('Error adding timeline event:', error);
      
      // Return a placeholder instead of throwing
      return {
        id: 'error-' + Date.now(),
        date: event.date,
        stage: event.eventType,
        title: event.title,
        description: `Unexpected Error: ${error instanceof Error ? error.message : 'Unknown error'}`
      };
    }
  }

  async createProcessTimelineEvent(event: { processId: string; stage: string; description: string; date: string }): Promise<ProcessTimelineEvent> {
    try {
      console.log('ProcessService.createProcessTimelineEvent called with:', event);
      
      // Generate a unique ID for the timeline event
      const eventId = `event-${Date.now()}`;
      console.log(`Generated timeline event ID: ${eventId}`);
      
      const { data: createdEvent, error } = await supabase
        .from('process_timeline_events')
        .insert({
          id: eventId, // Add explicit ID
          process_id: event.processId,
          stage: event.stage,
          description: event.description || '',
          date: event.date
          // Note: created_at has a DEFAULT NOW() so it's automatically set
        })
        .select()
        .single();

      if (error) {
        console.error('Error creating process timeline event:', error);
        throw error;
      }

      console.log('Process timeline event created successfully:', createdEvent);
      
      // Transform the database row to match ProcessTimelineEvent interface
      return {
        id: createdEvent.id,
        stage: createdEvent.stage,
        description: createdEvent.description,
        date: createdEvent.date
      };
    } catch (error) {
      console.error('Error in createProcessTimelineEvent:', error);
      throw error;
    }
  }

  /**
   * Metrics Service - Provides methods to calculate and retrieve process metrics
   */

  async getProcessMetrics(): Promise<{
    total: number;
    byStatus: Record<string, number>;
    byStage: Record<string, number>;
    avgEstimate: number;
  }> {
    try {
      const { data: processes, error } = await supabase
        .from('processes')
        .select('status, sdlc_stage, estimate');

      if (error) throw error;

      const total = processes.length;
      const byStatus: Record<string, number> = {};
      const byStage: Record<string, number> = {};
      let totalEstimate = 0;
      let estimateCount = 0;

      processes.forEach(process => {
        // Count by status
        byStatus[process.status] = (byStatus[process.status] || 0) + 1;
        
        // Count by SDLC stage
        byStage[process.sdlc_stage] = (byStage[process.sdlc_stage] || 0) + 1;
        
        // Calculate average estimate
        if (process.estimate) {
          totalEstimate += process.estimate;
          estimateCount++;
        }
      });

      const avgEstimate = estimateCount > 0 ? totalEstimate / estimateCount : 0;

      return {
        total,
        byStatus,
        byStage,
        avgEstimate
      };
    } catch (error) {
      console.error('Error getting process metrics:', error);
      throw error;
    }
  }
  private transformProcessRow(row: any): Process {
    return {
      id: row.id,
      name: row.name,
      description: row.description,
      jiraTicket: row.jira_ticket,
      status: row.status,
      startDate: row.start_date,
      dueDate: row.due_date,
      endDate: row.end_date,
      sdlcStage: row.sdlc_stage,
      estimate: row.estimate,
      devSprint: row.dev_sprint,
      approvalStatus: row.approval_status,
      approvedDate: row.approved_date,
      deployedDate: row.deployed_date,
      supportedTeamIds: row.supported_team_ids,
      functionalArea: row.functional_area,
      documentIds: row.document_ids,
      responsibleContactId: row.contact_id || null,
      progress: 0, // Default progress since this column doesn't exist in DB
      outputDeliveryMethod: row.output_delivery_method,
      outputDeliveryDetails: row.output_delivery_details,
      customerId: row.customer_id,
      // TPA fields
      isTpaRequired: row.is_tpa_required || false,
      tpaResponsibleContactId: row.tpa_responsible_contact_id || null,
      tpaDataSource: row.tpa_data_source || null,
      tpaStartDate: row.tpa_start_date || null,
      tpaEndDate: row.tpa_end_date || null,
      timeline: (row.process_timeline_events || []).map((event: any) => ({
        id: event.id,
        date: event.date || event.created_at,
        stage: event.stage,
        description: event.description
      }))
    };
  }
}
